<head>
  <title>Crossword Puzzle</title>
  <link rel="shortcut icon" href="/favicon.ico">
  <link rel="icon" href="/assets/favicon.svg" type="image/svg+xml">
  <link rel="stylesheet" href="style.css">
  <style>
    /* DO NOT style the puzzle grid itself beyond original td rule */
    td { width: 50px; height: 50px; text-align: center; vertical-align: middle; position: relative; }
    .hidden-text { color: transparent; }
  .number-span { position: absolute; top: 0; left: 0; pointer-events: none; color: #ffffff; }
    .editable-content { display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; }
    .rules { color: red; }

    /* Modern page chrome (excluding puzzle) */
    :root {
      --bg: #0f1121;
      --gradient: linear-gradient(135deg,#5522aa 0%,#7d2ae8 50%,#af7bff 100%);
      --panel: #ffffff;
      --panel-alt: #fafbff;
      --text: #1d2230;
      --muted: #5c6274;
      --accent: #7d2ae8;
      --accent-hover: #9150f0;
      --danger: #c62842;
      --radius: 14px;
      --radius-sm: 6px;
      --shadow: 0 8px 28px -8px rgba(34,8,70,.35),0 4px 16px -6px rgba(34,8,70,.25);
      --fade: 0.25s cubic-bezier(.4,.2,.2,1);
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      font-size: 16px;
    }
    html,body { margin:0; padding:0; background: var(--bg); color: var(--text); -webkit-font-smoothing: antialiased; }
    body { min-height: 100vh; display:flex; flex-direction:column; font-size: 1rem; }
    .page-shell { width:100%; max-width:1300px; margin:0 auto; padding: clamp(1rem,2vw,2rem) clamp(1rem,3vw,3rem) 3rem; flex:1; }
  .header-bar { display:flex; gap:1.5rem; align-items:center; justify-content:space-between; margin:0 0 1.2rem; position:relative; }
    .header-left h3 { margin:.15rem 0 .4rem; font-size:clamp(1.5rem,3vw,2rem); letter-spacing:.5px; background:var(--gradient); -webkit-background-clip:text; background-clip:text; color:transparent; }
    .header-left small { color: var(--muted); font-size:.9rem; letter-spacing:.5px; }
  .logout-form button { background: var(--accent); border:0; color:#fff; padding:.65rem 1.05rem; font-weight:600; font-size:.8rem; border-radius: var(--radius-sm); cursor:pointer; letter-spacing:.5px; box-shadow: 0 4px 16px -4px rgba(125,42,232,.55); transition: var(--fade); }
  .logout-form button:hover { background: var(--accent-hover); transform: translateY(-2px); }
  .logout-form button:active { transform: translateY(0); }

  /* Unified header buttons for alignment */
  .header-actions{ display:flex; gap:.6rem; align-items:center; }
  .header-btn{ display:inline-flex; align-items:center; justify-content:center; text-decoration:none; padding:.7rem 1rem; font-weight:600; font-size:.85rem; border-radius:6px; letter-spacing:.3px; min-height:40px; line-height:1; box-shadow:0 4px 16px -6px rgba(20,20,40,.4); }
  .header-btn--secondary{ background:#444e70; color:#fff; border:0; }
  .header-btn--secondary:hover{ filter:brightness(1.05); transform:translateY(-2px); }
  .header-btn--primary{ background:var(--accent); color:#fff; border:0; }
  .header-btn--primary:hover{ background:var(--accent-hover); transform:translateY(-2px); }
  /* Reduce visual weight for secondary button without changing size */
  .header-btn--secondary{ box-shadow:0 3px 12px -6px rgba(20,20,40,.35); font-weight:600 }
  /* Ensure logout button adopts unified sizing */
  .logout-form button.header-btn{ padding:.7rem 1rem; font-size:.85rem; border-radius:6px; min-height:40px; line-height:1; }

    .layout { display:grid; grid-template-columns: 1fr minmax(260px,340px); gap: clamp(1rem,2vw,2rem); align-items:start; }
    @media (max-width: 980px){ .layout { grid-template-columns:1fr; } }

    .panel { background: var(--panel); border-radius: var(--radius); padding: clamp(1rem,1.5vw,1.35rem) clamp(1rem,1.5vw,1.4rem) 1.4rem; box-shadow: var(--shadow); position:relative; overflow:hidden; backdrop-filter: blur(4px) saturate(140%); border:1px solid rgba(255,255,255,0.15); }
    .panel-alt { background: var(--panel-alt); }
    .panel h3 { margin:.1rem 0 1rem; font-size:1.15rem; letter-spacing:.5px; text-transform:uppercase; font-weight:700; color:#2d2f45; }

    .rules-box { margin:0 0 1.1rem; background:#1b1f33; color:#d6d9ef; padding:.75rem 1rem .8rem; border-radius: var(--radius-sm); font-size:.85rem; line-height:1.4; letter-spacing:.6px; border:1px solid #2a3355; box-shadow: inset 0 0 0 1px #2d3a63; }
    .rules-box code { background:#2a3355; padding:2px 5px; border-radius:4px; font-size:.8rem; }

    .hints-wrap { max-height:420px; overflow:auto; scrollbar-width: thin; scrollbar-color: var(--accent) #eceefe; font-size:.9rem; line-height:1.5; letter-spacing:.3px; }
    .hints-wrap::-webkit-scrollbar { width:10px; }
    .hints-wrap::-webkit-scrollbar-track { background:#eceefe; }
    .hints-wrap::-webkit-scrollbar-thumb { background: var(--accent); border-radius:8px; }

    .actions { display:flex; flex-wrap:wrap; gap:.75rem; margin-top:1.3rem; }
    .actions button { flex: 1; min-width: 140px; }
    #submitBtn { background:var(--gradient); border:0; color:#fff; padding:.85rem 1.4rem; font-size:.85rem; font-weight:600; border-radius: var(--radius-sm); letter-spacing:.75px; cursor:pointer; box-shadow:0 6px 22px -6px rgba(80,30,160,.55),0 3px 10px -4px rgba(80,30,160,.45); transition: var(--fade); position:relative; }
    #submitBtn:hover { filter:brightness(1.05); transform: translateY(-2px); }
    #submitBtn:active { transform: translateY(0); }

    .footer { margin-top:2.5rem; text-align:center; font-size:.65rem; letter-spacing:.8px; color:#9fa5bb; opacity:.85; }
    .footer a { color: var(--accent); text-decoration:none; }
    .footer a:hover { text-decoration:underline; }

    /* Keep puzzle table visually distinct: wrap in its own panel but do not target table/td beyond original */
    .puzzle-container { background: linear-gradient(145deg,#ffffff,#f7f9ff); border-radius: var(--radius); padding:1rem; box-shadow: var(--shadow); position:relative; }
    .puzzle-container:before { content:''; position:absolute; inset:0; border-radius:inherit; background: linear-gradient(135deg,rgba(125,42,232,.12),transparent 60%); pointer-events:none; }

    @media (prefers-color-scheme: dark) {
      :root { --panel:#1c2032; --panel-alt:#151929; --text:#e8eaf3; --muted:#8891ad; --bg:#060814; }
      .panel h3 { color:#e5e7f4; }
      .rules-box { background:#222a41; color:#cfd7ef; border-color:#334161; box-shadow:none; }
      .rules-box code { background:#2e3a57; }
      .puzzle-container { background: linear-gradient(160deg,#1c2032,#232b44); box-shadow:0 10px 32px -10px rgba(0,0,0,.75); }
      .puzzle-container:before { background: linear-gradient(135deg,rgba(125,42,232,.25),transparent 70%); }
      #submitBtn { box-shadow:0 6px 32px -8px rgba(125,42,232,.65),0 4px 16px -10px rgba(125,42,232,.5); }
    }

    /* Toast notifications */
    .toast-container { position: fixed; top: 16px; right: 16px; display: flex; flex-direction: column; gap: 10px; z-index: 1000; }
    .toast { background: #1c2032; color: #e8eaf3; border: 1px solid #2d3350; padding: .75rem 1rem; border-radius: 8px; box-shadow: var(--shadow); min-width: 220px; max-width: 360px; font-size: .9rem; letter-spacing:.3px; display:flex; align-items:center; justify-content:space-between; gap:.75rem; animation: toast-in .2s ease-out; }
    .toast--success { border-color: #2f7d4a; background: #14251c; color: #c7f0d6; }
    .toast--error { border-color: #7d2a3a; background: #2b151b; color: #ffd2d8; }
    .toast--info { border-color: #4258a8; background: #131a2f; color: #d6defc; }
    .toast__close { background: transparent; border: 0; color: inherit; cursor: pointer; font-size: 1rem; opacity: .8; }
    .toast__close:hover{ opacity: 1; }
    @keyframes toast-in { from { opacity: 0; transform: translateY(-6px);} to { opacity:1; transform: translateY(0);} }
  </style>
</head>

<body>
  <div class="toast-container" id="toastContainer" aria-live="polite" aria-atomic="true"></div>
  <div class="page-shell">
    <div class="header-bar">
      <div class="header-left">
        <h3>Crossword Challenge</h3>
        <small>Fill the grid then press submit to check your score. Total Score: <span id="totalScore">-</span> | Time: <span id="timer">0:00</span></small>
      </div>
      <div class="header-actions">
        <a href="/" class="header-btn header-btn--secondary">← Back to Dashboard</a>
      </div>
    </div>    <div class="rules-box">* Please use simple English letters only. Black squares are blocked positions. Numbers indicate clue starts.</div>

    <div class="layout">
      <div class="puzzle-container">
        <table id="myTable" border="1">
    <tbody>
      <!-- 10x10 table -->
      <script>
        const tableBody = document.createElement('tbody');
        for (let i = 0; i < 10; i++) {
          const row = document.createElement('tr');
          for (let j = 0; j < 10; j++) {
            const cell = document.createElement('td');
            const editableDiv = document.createElement('div');
            editableDiv.className = 'editable-content'; // Add class for styling
            editableDiv.contentEditable = true; // Make the cell's content editable
            editableDiv.setAttribute('tabindex', '0');
            editableDiv.dataset.row = String(i);
            editableDiv.dataset.col = String(j);

            // Add input event to limit cell input to one character
            editableDiv.addEventListener('input', function () {
              if (editableDiv.textContent.length > 1) {
                editableDiv.textContent = editableDiv.textContent[0]; // Keep only the first character
              }
            });

            cell.appendChild(editableDiv);
            row.appendChild(cell);
          }
          tableBody.appendChild(row);
        }
        document.getElementById('myTable').appendChild(tableBody);
      </script>
    </tbody>
        </table>
      </div>
      <div class="panel panel-alt">
        <h3>Hints</h3>
        <div id="hints" class="hints-wrap"></div>
        <div class="actions">
          <button id="submitBtn">Submit</button>
          <button id="resetBtn" style="background:#6b7280;color:#fff;border:0;padding:.85rem 1.2rem;font-weight:600;border-radius:6px;cursor:pointer">Reset</button>
          <button id="saveBtn" style="background:#444e70;color:#fff;border:0;padding:.85rem 1.2rem;font-weight:600;border-radius:6px;cursor:pointer">Save Progress</button>
        </div>
      </div>
    </div>
    <div class="footer">&copy; <span id="year"></span> Crossword App</div>
  </div>

  <script>
    // Footer year
    document.addEventListener('DOMContentLoaded',()=>{ const y=document.getElementById('year'); if(y) y.textContent=new Date().getFullYear(); });

    // Load current score
    async function loadScore(){
      try { const r = await fetch('/me'); if(!r.ok) return; const j = await r.json(); document.getElementById('totalScore').textContent = j.score; } catch(_){}
    }
    loadScore();

    // Fetch the string from the Node.js server (puzzle data)
    fetch('/data')
      .then(response => response.json())
      .then(data => {
  var output = data.output
  var myStringUnedited = data.myStringUnedited
  var answerArrayFlat = data.answerArrayFlat
  var legendServer = data.legend || ''
  var userAnswers = data.userAnswers || null

        // Check if the output contains the number "10"
        if (myStringUnedited.includes("10")) {
          window.location.reload(); // Reload the page
        }

  const legend = legendServer || '';

        let solvedLock = false; // prevent resubmission after solved
        let puzzleIdGlobal = data.puzzleId;
        
        // Timer logic
        let elapsedSeconds = data.elapsedTime || 0; // Load from server
        let timerInterval = null;
        const timerDisplay = document.getElementById('timer');
        
        function formatTime(seconds) {
          const h = Math.floor(seconds / 3600);
          const m = Math.floor((seconds % 3600) / 60);
          const s = seconds % 60;
          if (h > 0) return `${h}:${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
          return `${m}:${String(s).padStart(2,'0')}`;
        }
        
        function updateTimerDisplay() {
          if (timerDisplay) timerDisplay.textContent = formatTime(elapsedSeconds);
        }
        
        function startTimer() {
          if (timerInterval) return; // Already running
          timerInterval = setInterval(() => {
            elapsedSeconds++;
            updateTimerDisplay();
          }, 1000);
        }
        
        function stopTimer() {
          if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
          }
        }
        
        // Page Visibility API: pause when user leaves page
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            stopTimer();
          } else {
            startTimer();
          }
        });
        
        // Start timer on page load
        updateTimerDisplay();
        startTimer();
        
        const submitBtn = document.getElementById('submitBtn');
        const saveBtn = document.getElementById('saveBtn');
        // Simple toast helper
        function showToast(message, type = 'info', timeout = 3000){
          try {
            const cont = document.getElementById('toastContainer');
            if(!cont) { console.log(message); return; }
            const el = document.createElement('div');
            el.className = `toast toast--${type}`;
            el.innerHTML = `<span>${message}</span><button class="toast__close" aria-label="Close" title="Close">×</button>`;
            el.querySelector('.toast__close')?.addEventListener('click', ()=>{ el.remove(); });
            cont.appendChild(el);
            setTimeout(()=>{ el.remove(); }, timeout);
          } catch(_) { console.log(message); }
        }
        saveBtn?.addEventListener('click', async function(){
          try {
            const edits = document.querySelectorAll('#myTable td .editable-content');
            const currentAnswers = Array.from(edits).map(el => {
              if (!el.isContentEditable) return '-';
              const t = (el.textContent || '').trim().replace(/\d/g, '');
              return t === '' ? '-' : t[0];
            }).join('');
            await fetch('/save-progress', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ puzzleId: puzzleIdGlobal, answers: currentAnswers, elapsedTime: elapsedSeconds }) });
            showToast('Progress saved', 'success');
          } catch(_){ showToast('Failed to save', 'error'); }
        });
        document.getElementById('submitBtn').addEventListener('click', async function () {
          if (solvedLock) { showToast('You have already solved this puzzle.', 'info'); return; }
          // Build the current answers string from editable cells only (skip black squares)
          const edits = document.querySelectorAll('#myTable td .editable-content');
          const currentAnswers = Array.from(edits).map(el => {
            if (!el.isContentEditable) return '-';
            const t = (el.textContent || '').trim().replace(/\d/g, '');
            return t === '' ? '-' : t[0];
          }).join('');

          // Validate lengths
          if (answerArrayFlat.length !== currentAnswers.length) {
            showToast(`Lengths are not equal (${currentAnswers.length} vs ${answerArrayFlat.length}). Please refresh.`, 'error', 5000);
            return;
          }

          // Compare strings
          const correct = currentAnswers === answerArrayFlat;
          if (!correct) {
            // Save progress with current entry so user resumes later
            try {
              await fetch('/save-progress', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ puzzleId: puzzleIdGlobal, answers: currentAnswers, elapsedTime: elapsedSeconds }) });
            } catch (_) {}
            try {
              const resp = await fetch('/submit-score', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ puzzleId: puzzleIdGlobal, correct:false }) });
              const resj = await resp.json();
              if (resj.mustRestart) {
                showToast('Wrong answer. No attempts remaining. The page will restart.', 'error', 5000);
                window.location.reload(true);
                return;
              }
              const rem = typeof resj.remainingAttempts === 'number' ? resj.remainingAttempts : 0;
              showToast(`Wrong answer. Attempts remaining: ${rem}`, 'error');
            } catch (_) {
              showToast('Wrong answer.', 'error');
            }
            return;
          }
          // correct -> award point if first time
            try {
              stopTimer(); // Stop timer when puzzle is solved
              const resp = await fetch('/submit-score', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ puzzleId: puzzleIdGlobal, correct:true, elapsedTime: elapsedSeconds }) });
              const result = await resp.json();
              if (result.alreadySolved) {
                solvedLock = true;
                showToast(`Already solved earlier. Total: ${result.score}`, 'info');
                document.getElementById('totalScore').textContent = result.score;
                // Load a fresh puzzle immediately
                setTimeout(() => { window.location.reload(true); }, 400);
              } else if (resp.ok) {
                solvedLock = true;
                showToast(`Score this puzzle: 1 (Total: ${result.score})`, 'success');
                document.getElementById('totalScore').textContent = result.score;
                // Load a fresh puzzle immediately
                setTimeout(() => { window.location.reload(true); }, 400);
              } else {
                showToast('Solved, but failed to record score', 'error');
              }
            } catch (e) {
              showToast('Solved, but error recording score', 'error');
            }
        });

  let sentences = legend.split('.');

        // Initialize a new paragraph string
        let newParagraph = '';

        // Loop through the sentences and add them to the new string
        for (let i = 0; i < sentences.length; i++) {
          newParagraph += sentences[i].trim(); // Remove extra spaces

          // Check if the index is even (i + 1 is the count of full stops)
          if ((i + 1) % 2 === 0) {
            newParagraph += '.<br>'; // Add a line break after every even full stop
          } else {
            newParagraph += '.'; // Add the full stop for odd indices
          }
        }

        // Remove any trailing line breaks or spaces
        //newParagraph = newParagraph.replace(/\s*<br>\s*$/, '');
        hints = document.getElementById('hints')
        //console.log(newParagraph)
        newParagraph = newParagraph.replace(/\.([^\s])/g, '. $1');
        hints.innerHTML = newParagraph;

        // Clean up the string by removing line breaks
        myStringLine = myStringUnedited.replaceAll('\n', '').replaceAll('\r', ''); // Replace line breaks
        //console.log(myStringLine);

        // Create an array of characters from the cleaned string
        myStringArray = Array.from(myStringLine);
        myString = '';

        // Build the string from even indexed characters
        for (let i = 0; i < myStringArray.length; i += 1) {
          myString += myStringArray[i];
        }

  const table = document.getElementById('myTable');
  const rows = table.getElementsByTagName('tr');
        let index = 0;

        // Loop through each cell and fill with characters from the string
        for (let i = 0; i < rows.length; i++) {
          const cells = rows[i].getElementsByTagName('td');
          for (let j = 0; j < cells.length; j++) {
            if (index < myString.length) {
              const editableDiv = cells[j].querySelector('.editable-content');
              editableDiv.textContent = myString[index++];
            } else {
              cells[j].querySelector('.editable-content').textContent = ''; // Leave empty if string ends
            }

            // Check if cell contains '-' after populating the table
            if (cells[j].querySelector('.editable-content').textContent === '-') {
              cells[j].style.backgroundColor = 'black'; // Change background color
              cells[j].querySelector('.editable-content').textContent = ''; // Remove the text completely
              cells[j].querySelector('.editable-content').contentEditable = false; // Make the editable div uneditable
              cells[j].style.pointerEvents = 'none'; // Disable any mouse events for the cell
            }

            // Check if the cell contains a number
            const numberMatch = cells[j].querySelector('.editable-content').textContent.match(/\d/);
            if (numberMatch) {
              const number = numberMatch[0]; // Extract the number
              const editableDiv = cells[j].querySelector('.editable-content');

              // Clear the number from the editable content
              editableDiv.textContent = editableDiv.textContent.replace(number, '');

              // Create a span to display the number, make it uneditable
              const numberSpan = document.createElement('span');
              numberSpan.textContent = number;
              numberSpan.className = 'number-span'; // Apply styles for the number
              numberSpan.contentEditable = false; // Make the number uneditable

              // Insert the span into the cell, aligning it top-left
              cells[j].appendChild(numberSpan);
            }
          }
        }

        // Snapshot the initial beginning form answers (after black squares and numbers processed), before applying any saved user answers
        const initialEdits = document.querySelectorAll('#myTable td .editable-content');
        const initialAnswersString = Array.from(initialEdits).map(el => {
          if (!el.isContentEditable) return '-';
          const t = (el.textContent || '').trim();
          return t === '' ? '-' : t[0];
        }).join('');

        // Arrow key navigation across cells (skip non-editable/black squares)
        function getCellEl(r, c) {
          return document.querySelector(`#myTable td .editable-content[data-row="${r}"][data-col="${c}"]`);
        }
        function focusCell(el) {
          if (!el) return;
          el.focus();
          // Select existing content so typing replaces it
          try {
            const sel = window.getSelection();
            const range = document.createRange();
            range.selectNodeContents(el);
            sel.removeAllRanges();
            sel.addRange(range);
          } catch(_){}
        }
        function move(el, dr, dc) {
          let r = parseInt(el.dataset.row, 10);
          let c = parseInt(el.dataset.col, 10);
          while (true) {
            r += dr; c += dc;
            if (r < 0 || r >= 10 || c < 0 || c >= 10) return; // boundary
            const next = getCellEl(r, c);
            if (next && next.isContentEditable) { focusCell(next); return; }
          }
        }
        document.querySelectorAll('#myTable td .editable-content[contenteditable="true"]').forEach(el => {
          el.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight') { e.preventDefault(); move(el, 0, 1); }
            else if (e.key === 'ArrowLeft') { e.preventDefault(); move(el, 0, -1); }
            else if (e.key === 'ArrowDown') { e.preventDefault(); move(el, 1, 0); }
            else if (e.key === 'ArrowUp') { e.preventDefault(); move(el, -1, 0); }
          });
        });

        // If server provided saved user answers, apply them into the grid
        if (userAnswers && typeof userAnswers === 'string') {
          const edits = document.querySelectorAll('#myTable td .editable-content');
          for (let i = 0; i < Math.min(userAnswers.length, edits.length); i++) {
            const el = edits[i];
            if (!el.isContentEditable) continue; // skip black squares
            const ch = userAnswers[i];
            if (ch && ch !== '-') {
              el.textContent = ch;
            }
          }
        }

        // Optional: auto-save every 20 seconds
        setInterval(() => {
          try {
            const edits = document.querySelectorAll('#myTable td .editable-content');
            const current = Array.from(edits).map(el => {
              if (!el.isContentEditable) return '-';
              const t = (el.textContent || '').trim();
              return t === '' ? '-' : t[0];
            }).join('');
            if (puzzleIdGlobal) {
              fetch('/save-progress', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ puzzleId: puzzleIdGlobal, answers: current, elapsedTime: elapsedSeconds }) });
            }
          } catch (_){ }
        }, 20000);

        // Reset button restores initial beginning form and persists it
        const resetBtn = document.getElementById('resetBtn');
        resetBtn?.addEventListener('click', async function(){
          if (!confirm('Reset puzzle to its beginning state? All your current inputs will be cleared. Timer will also reset.')) return;
          try {
            const edits = document.querySelectorAll('#myTable td .editable-content');
            for (let i = 0; i < edits.length; i++) {
              const el = edits[i];
              if (!el.isContentEditable) continue;
              const ch = initialAnswersString[i] || '-';
              el.textContent = ch === '-' ? '' : ch;
            }
            // Reset timer
            elapsedSeconds = 0;
            updateTimerDisplay();
            if (puzzleIdGlobal) {
              await fetch('/save-progress', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ puzzleId: puzzleIdGlobal, answers: initialAnswersString, elapsedTime: 0 }) });
            }
            showToast('Puzzle reset to beginning form', 'success');
          } catch(_){ showToast('Failed to reset', 'error'); }
        });
      })
      .catch(error => console.error('Error fetching data:', error));

  </script>
</body>